右值引用解决移动语义问题，移动语义主要有两方面：1.传参2.返回值。右值引用的移动语义能将资源(堆、系统对象等)通过浅拷贝从一个对象转移到另一个对象中，从而减少不必要的临时对象的深拷贝，
可以提高c++程序的性能。  
  
 
![](https://github.com/gongchaosheng/C-Plus-Plus/blob/main/picture/%E5%BC%95%E7%94%A8.jpg)

这个图片非常好的说明了右值引用的优点。当没有右值引用仅仅按值传递时，会调用两次拷贝构造函数，使用右值引用后仅仅调用移动构造即可。  
再来看看右值引用相对于常量引用的优点：
```
// 函数1，接受左值引用
void process_copy(const std::vector<int>& vec_) {
    // do_something
    std::vector<int> vec(vec_); //  不能修改左值，所以要拷贝vector
    vec.push_back(42);
}

// 函数2，接受右值引用
void process_copy(std::vector<int> && vec) {
    vec.push_back(42); // 直接修改右值
}

int main(){
    std::vector<int> data;
    process_copy(data); // 调用函数1
    process_copy(std::vector<int>()); // 调用函数2，临时对象作为右值，函数内部无需拷贝，降低开销
    return 0;
}
```
这种情况右值引用少一次拷贝构造，并且右值引用允许修改vec。

**所以总结一下，右值引用既解决了普通引用的拷贝开销大问题，又解决了常量引用的无法修改对象的问题**





来看看左右值引用的区别吧
+ 左值引用使用&绑定，右值引用使用&&绑定且只能绑定在一个即将销毁的对象或者字面常量上。
+ 左值引用绑定在一个"对象"上，右值引用绑定在"值"上。
+ 左值引用不能绑定在要求转换的表达式、字面常量或者返回右值的表达式上，右值引用可以，但是右值引用不能绑定在左值上。
+ 左值持久，右值短暂。
例如：
```
int i = 40; //i是一个左值,变量是左值。
int &r1 = i; //正确。
int &&r2 = i; //错误，右值引用不能绑定在左值上。
int &&r3 = i * 2; //正确，此表达式返回了一个右值。
```
因为变量是左值，所以不能将右值引用绑定在一个右值引用上
```
int &&r1 = 42; //正确，42是字面常量，右值。
int &&r2 = r1; //错误，r1是左值。
```
