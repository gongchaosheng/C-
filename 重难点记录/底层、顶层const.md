## const引用(常量引用)
常量对象不能绑定在非常量引用上，比如
```
const int i = 0;  
int &r = i;  //错误
```
不管是常量引用还是非常量引用都能绑定在常量引用上：
```
int i = 0;
const int &r = i;//正确
```
常量引用的含义就是无法通过本引用改变引用的对象。  

## const指针
对于指针来说，有顶层`const`和底层`const`。
+ **顶层`const`** 即指针`p`本身是常量，无法修改指针`p`的值。指针可以看作在底层数据之上，因此是顶层`const`
+ **底层`const`** 即指针`p`指向的对象是常量，此值无法修改。数据在底层，因此是底层`const`
+ **说白了距离p近的是顶层const**
下面来定义一个指针：
```
int i = 0;
const int j = 1;

const int *p1 = &i; //正确，底层const，指针p1指向的对象是常量，p1的类型是int*
int * const p2 = &j; //错误，&j是const int *类型，是底层指针，不能绑定在顶层指针p2上
int * const p2 = &i; //正确，顶层const,指针p2本身是常量，p2的类型是int* const
```
如何分辨这两种指针呢？从指针由内而外看，`p1`先和`*`结合，因此`p1`首先是个指针，继续向外，p1指向的对象是`const int`类型，所以`p1`是个底层`const`。  
`p2`先和`const`结合，说明`p2`首先是个`const`对象，之后和`*`结合，说明`p2`是一个常量指针。  
注意，在拷贝的时候底层`const`对象不能给没有底层`const`的对象赋值。即`p2=p1`是错误的，因为`p2`是一个顶层`const`，而`p1`是底层`const`



